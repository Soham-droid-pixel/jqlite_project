/**
 * json.l
 * 
 * Flex lexer specification for JSON.
 * Tokenizes JSON input including strings, numbers, booleans, null,
 * and structural characters.
 */

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "json_value.h"
#include "json.tab.h"  // Generated by Bison, contains token definitions

/* Helper function to process escape sequences in strings */
char* process_string(const char* str);
%}

/* Options for the lexer */
%option noyywrap
%option noinput
%option nounput

%%

    /* Whitespace - ignore */
[ \t\n\r]+              { /* Skip whitespace */ }

    /* JSON structural characters */
"{"                     { return LBRACE; }
"}"                     { return RBRACE; }
"["                     { return LBRACK; }
"]"                     { return RBRACK; }
","                     { return COMMA; }
":"                     { return COLON; }

    /* JSON literals */
"true"                  { return TRUE; }
"false"                 { return FALSE; }
"null"                  { return NULL_TOKEN; }

    /* JSON numbers */
-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?  {
    json_yylval.number = atof(json_yytext);
    return NUMBER;
}

    /* JSON strings */
\"([^\\\"]|\\.)*\"      {
    /* Remove quotes and process escape sequences */
    char* str = process_string(json_yytext);
    json_yylval.string = str;
    return STRING;
}

    /* Anything else is an error */
.                       {
    fprintf(stderr, "JSON Lexer: Unexpected character '%c'\n", json_yytext[0]);
    return ERROR;
}

%%

/**
 * Process escape sequences in a JSON string.
 * This function removes the surrounding quotes and handles basic escapes.
 * 
 * @param str The raw string token including quotes
 * @return A newly allocated string with escapes processed
 */
char* process_string(const char* str) {
    int len = strlen(str);
    char* result = (char*)malloc(len); // Allocate enough space (will be smaller after processing)
    int j = 0;
    
    // Skip opening quote and process until closing quote
    for (int i = 1; i < len - 1; i++) {
        if (str[i] == '\\' && i + 1 < len - 1) {
            // Handle escape sequences
            i++; // Skip the backslash
            switch (str[i]) {
                case 'n':  result[j++] = '\n'; break;
                case 't':  result[j++] = '\t'; break;
                case 'r':  result[j++] = '\r'; break;
                case '\\': result[j++] = '\\'; break;
                case '"':  result[j++] = '"'; break;
                case '/':  result[j++] = '/'; break;
                case 'b':  result[j++] = '\b'; break;
                case 'f':  result[j++] = '\f'; break;
                default:   result[j++] = str[i]; break; // Unknown escape, keep as-is
            }
        } else {
            result[j++] = str[i];
        }
    }
    result[j] = '\0';
    return result;
}
