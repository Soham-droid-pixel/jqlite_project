/**
 * query.l
 * 
 * Flex lexer specification for the jqlite query language.
 * UPGRADED VERSION with Compiler Visualization support.
 */

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "json_value.h"
#include "query.tab.h"  // Generated by Bison, contains token definitions

/* External visualization mode flag */
extern int g_visualize_mode;
static int token_count = 0;

/* Helper function to print token in visualize mode */
void log_token(const char* type, const char* value) {
    if (g_visualize_mode) {
        if (token_count > 0) {
            printf(",");
        }
        printf("{\"type\":\"%s\",\"value\":\"%s\"}", type, value);
        token_count++;
    }
}

void log_token_num(const char* type, double value) {
    if (g_visualize_mode) {
        if (token_count > 0) {
            printf(",");
        }
        printf("{\"type\":\"%s\",\"value\":\"%g\"}", type, value);
        token_count++;
    }
}
%}

/* Options for the lexer */
%option noyywrap
%option noinput
%option nounput

%%

    /* Whitespace - ignore */
[ \t\n\r]+              { /* Skip whitespace */ }

    /* Query operators */
"."                     { log_token("DOT", "."); return DOT; }
"["                     { log_token("LBRACK", "["); return LBRACK; }
"]"                     { log_token("RBRACK", "]"); return RBRACK; }
"|"                     { log_token("PIPE", "|"); return PIPE; }
"("                     { log_token("LPAREN", "("); return LPAREN; }
")"                     { log_token("RPAREN", ")"); return RPAREN; }
":"                     { log_token("COLON", ":"); return COLON; }

    /* Comparison operators */
"=="                    { log_token("EQ", "=="); return EQ; }
"!="                    { log_token("NEQ", "!="); return NEQ; }
">="                    { log_token("GTE", ">="); return GTE; }
"<="                    { log_token("LTE", "<="); return LTE; }
">"                     { log_token("GT", ">"); return GT; }
"<"                     { log_token("LT", "<"); return LT; }

    /* Keywords */
"select"                { log_token("SELECT", "select"); return SELECT; }

    /* Numbers (integers and floats) */
-?[0-9]+\.?[0-9]*       {
    query_yylval.number = atof(query_yytext);
    log_token_num("NUMBER", query_yylval.number);
    return NUMBER;
}

    /* Field identifiers (alphanumeric + underscore, starting with letter or underscore) */
[a-zA-Z_][a-zA-Z0-9_]*  {
    query_yylval.string = strdup(query_yytext);
    log_token("IDENT", query_yytext);
    return IDENT;
}

    /* Anything else is an error */
.                       {
    if (!g_visualize_mode) {
        fprintf(stderr, "Query Lexer: Unexpected character '%c'\n", query_yytext[0]);
    }
    return ERROR;
}

%%
